\section{Technology Assessment}
\label{sec:technology}


Introduce in (sufficient) depth the key concepts and architecture of the chosen software technology. As part if this, you may consider using a running example to introduce the technology.

This part and other parts of the report probably needs to refer to
figures. Figure~\ref{fig:framework} from \cite{brown:96} just
illustrates how figure can be included in the report.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{figs/framework.png}
	\caption{Software technology evaluation framework.}
	\label{fig:framework}
\end{figure}

\subsection{Descriptive Modeling}

write where the technology comes from, its history, its context and what problem it solves.
Consider drawing a graph like in \cite{brown:96}.

\subsection{Experiment Design}
\subsubsection{Introduction}

The selection of a programming language is one of the first and most consequential decisions in backend development, as it affects productivity, maintainability, and software quality. In today’s enterprise landscape, Java remains the default choice for many organisations due to its maturity, stability, and extensive ecosystem. Kotlin, a more recent statically typed language targeting the JVM, offers a different point in the design space: it is fully interoperable with Java while aiming to improve type safety, reduce boilerplate, and provide more expressive language constructs.

In this project, we use Brown and Wallnau’s Technology Delta Framework (1996/1999) to evaluate the use of Kotlin instead of Java for a poll-voting web application. The framework guides us to (i) analyse the genealogy of the technologies, (ii) characterise the problem habitat in which they are applied, and (iii) identify feature deltas that may influence quality, cost, and performance. These deltas then form the basis for a set of refutable hypotheses and experiments such as model problems, micro-benchmarks, and demonstrator case studies that allow us to reason systematically about the added value and risks of adopting Kotlin.

The chosen application is a REST-based poll-voting system where users can create polls, cast votes, and view results provides a realistic habitat for this evaluation. It stresses concurrency handling, transactional consistency, scalability, and rapid evolution of business logic. This makes it well-suited to test whether Kotlin’s features such as null-safety, data classes, coroutines, and type inference lead to measurable benefits over Java. 

\subsection{Descriptive Modelling}

\section*{Kotlin: Genealogy, Habitat, and Problem Context}
\subsection*{1. Genealogy}
\begin{itemize}
    \item \textbf{Origin (2011):} Created by \textbf{JetBrains} (makers of IntelliJ). Designed not as an academic experiment, but as a tool to boost industry productivity.
    \item \textbf{Turning Point (2017):} Google announced Kotlin as a first-class language for Android, shifting it from a niche alternative to an industry standard.
\end{itemize}

\subsection*{2. Habitat}
\begin{itemize}
    \item \textbf{JVM Ecosystem:} Kotlin lives on the Java Virtual Machine.
    \item \textbf{Interoperability:} Its defining feature is 100\% interoperability. Kotlin code can call Java code (and vice-versa) within the same project, allowing for incremental adoption rather than a total rewrite.
\end{itemize}

\subsection*{3. Problem Context}
Kotlin was engineered specifically to fix the shortcomings of Java:
\begin{description}
    \item[Null Safety:] Addresses the 
    NullPointerExceptions by baking null-checks directly into the type system.
    \item[Verbosity:] Drastically reduces boilerplate code. Standard tasks (POJOs, Getters/Setters) are often reduced from 50 lines in Java to 1 line in Kotlin.
    \item[Concurrency:] Solves the complexity of multi-threading with \textit{Coroutines}, allowing asynchronous code to be written in a sequential, readable style.
\end{description}

\begin{table}[ht]
    \centering
    \caption{\textbf{Genealogy primitives applied to kotlin}}
    \label{tab:kotlin_primitives}
    \vspace{0.2cm}
    
    \begin{tabular}{l l p{4.5cm} p{5cm}} 
        \toprule
        \textbf{Primitive} & \textbf{Form} & \textbf{Interpretation} & \textbf{Application to Kotlin} \\
        \midrule
        Technology & Node & A class of functionality & JVM-based Programming Languages \\
        
        Specification & Node & Description for producers consumers & The Kotlin Language Specification \\
        
        Product & Node & Implementation of a technology & The Kotlin Compiler (kotlinc) \& Standard Library \\
        
        Peer & Link & Nodes with similar features & Scala, Groovy  \\
        
        Competitor & Link & Products that compete in the marketplace & Java , Swift for mobile \\
        
        Problem context & Link & Problems addressed by a node & Null-safety, Verbosity of Java, Asynchronous complexity \\
        
        Is-a & Link & Instance of a technology & Kotlin \textit{is-a} statically typed language \\
        
        Part-of & Link & Bundled products/specs & Kotlin Coroutines \textit{part-of} Kotlin ecosystem \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Technology Genealogy}
Java and Kotlin have a shared family of technologies, the Java Virtual Machine (JVM) platform.
Java is an object-orientated statically typed programming language that was developed by Sun Microsystems in 1995. Java became popular due to its portability, mature tooling, and rich libraries. The design of Java was based on backward compatibility and explicitness. Java is a secure but verbose choice for most large systems, and increasingly Java has added more functional programming capabilities such as lambdas, streams, records, sealed classes, and virtual threads. That is, Java meeting the needs of expressiveness and concurrency.
Kotlin was created by JetBrains in 2011. Kotlin was marketed as a practical evolution of Java.
It was designed to solve Java's verbosity, its null-safety gap, and poor support for modern development paradigms with complete Java library and framework interoperability. It is also formally supported by notable JVM frameworks like Spring and Android and compiles to the same JVM bytecode. The design of Kotlin is conciseness-focused and safety, with interoperability, whereby one may use a more expressive syntax and a stable type system. Kotlin does not replace Java yet, however, it can be said to be an evolutionary offspring on the JVM family tree. It takes the core features of Java and extends them with other language elements from functional languages and statically typed languages like Scala, Swift, and C\#.

\subsubsection{Problem Habitat}

The technologies are evaluated in the context of a \textit{server-side poll-voting web application}. 
The system allows users to create polls, submit votes, and retrieve aggregate results via a REST-based 
HTTP API. This environment is representative for modern web backends built on the JVM and exposes 
several characteristics that are particularly relevant when comparing Java and Kotlin.

First, the application must handle bursty, concurrent traffic. Multiple users can vote on the same 
poll in a short period of time, which results in many parallel requests to endpoints such as 
\texttt{POST /vote} and \texttt{GET /tally}. The backend therefore needs efficient concurrency mechanisms 
to process I/O-bound operations caching, and network calls without exhausting threads.

Second, the domain requires strong data integrity and consistency. Each user should only be able to 
vote once per poll and each vote must be recorded exactly once. This implies transactional interactions 
with the persistence layer, correct handling, and careful management of edge cases 
such as duplicate submissions, retries, and partial failures. Subtle bugs in null-handling or state 
modelling can lead directly to incorrect results.

Third, the system must deliver low-latency responses under load. Users expect the poll results to update 
quickly after voting, and the application may be deployed in environments with limited resources. This 
puts pressure on both the runtime performance of the language features and the clarity of the asynchronous 
control flow implemented.

Finally, the project is developed in an educational and iterative setting, where requirements evolve and 
features are frequently adjusted. This makes the process more productive and readable.
The backend is built on the Spring ecosystem, originally designed for Java.

In summary, the habitat is a JVM-based web backend that emphasises concurrency, correctness, 
performance, and evolvability. This environment makes it possible to meaningfully assess 
whether Kotlin's language features such as null-safety, data classes, coroutines, and extension functions
provide measurable advantages over Java when applied to a realistic application.


\subsubsection{Feature Deltas}

The \textit{feature deltas} represent the specific technological innovations or differences introduced by Kotlin relative to Java.
These are the ``points of departure'' that may influence quality, cost, or performance outcomes within this application's habitat.

\begin{table}[H]
\centering
\caption{Feature Deltas between Java and Kotlin}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}p{0.17\linewidth} p{0.17\linewidth} p{0.17\linewidth} p{0.17\linewidth}@{}}
\toprule
\textbf{Feature Delta} & \textbf{Java (Baseline)} & \textbf{Kotlin (New Capability)} & \textbf{Potential Impact} \\ 
\midrule
\textbf{Null-safety} & 
Nullable references unchecked at compile time &
Non-nullable types enforced by compiler &
Reduces null pointer exceptions and improves reliability. \\

\textbf{Data classes} &
Verbose POJO definitions or JDK records (since Java 16) &
One-line \texttt{data class} with auto-generated methods &
Reduces boilerplate; increases development speed and readability. \\

\textbf{Type inference and concise syntax} &
Explicit type declarations &
Implicit typing with smart inference &
Simplifies code and reduces cognitive load on developers. \\

\textbf{Coroutines and structured concurrency} &
Threads, Executors, CompletableFuture, or Virtual Threads &
Lightweight coroutines with \texttt{suspend} functions &
Improves scalability and simplifies asynchronous programming. \\

\textbf{Extension functions} &
Utility methods via static helper classes &
Ability to attach behaviour directly to existing classes &
Enhances readability and enables domain-specific DSLs (e.g., Spring configuration). \\

\textbf{Sealed and inline classes} &
Limited polymorphic control (until Java 17) &
Exhaustive \texttt{when} expressions and sealed hierarchies &
Safer domain modelling and compile-time exhaustiveness checks. \\

\textbf{Interoperability with Java} &
Native language, direct compatibility &
Full interoperability using \texttt{@Jvm*} annotations and mixed modules &
Enables gradual adoption and reuse of existing Java codebases. \\

\textbf{Tooling and ecosystem support} &
Broad IDE and build support (Eclipse, IntelliJ, Gradle) &
First-class support in IntelliJ IDEA, Gradle, and Spring Boot &
Comparable or improved developer experience and productivity. \\
\bottomrule
\end{tabular}
\end{table}

From a descriptive perspective, Kotlin’s deltas can be grouped into three broad categories:
\begin{enumerate}
    \item \textbf{Safety} – achieved through null-safety and sealed type hierarchies.
    \item \textbf{Expressiveness} – enabled by concise syntax, data classes, and extension functions.
    \item \textbf{Concurrency and performance} – improved through lightweight coroutines and structured concurrency.
\end{enumerate}

\subsection{Experiment Evaluation}

Write about the results of your experiments, either via personal experience reports, quantitative benchmarks, a demostrator case study or a combination of multiple approaches.


For some reports you may have to include a table with experimental
results are other kinds of tables that for instance compares
technologies. Table~\ref{tab:results} gives an example of how to create a table.

\begin{table}[bth]
	\centering
	\begin{tabular}{llrrrrrr}
		Config & Property & States & Edges & Peak & E-Time & C-Time & T-Time
		\\ \hline \hline
		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  485.7\% \\
		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  471.4\% \\
		30-2 & B   &   14,672  &   41,611  &  4.9  \%  & 14 ms & 42.9\% &  464.3\% \\
		30-2 & C   &   14,672  &   41,611  &  4.9  \%  & 15 ms & 40.0\% &  420.0\% \\ \hline
		10-3 & D   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 31.4\% &  285.7\% \\
		10-3 & E   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 34.3\% &  308.6\% \\
		\hline \hline
	\end{tabular}
	\caption{Selected experimental results on the communication protocol example.}
	\label{tab:results}
\end{table}

\subsubsection{Readability and Maintainability}

To verify the hypotheses that Kotlin code is more readable than Java code we
took the lines of code into account. \\
Our assumptions in regard to this factor is that code is generally more
readable if it has less lines of code compared to another language.
The reasoning for this is: The fewer lines of code a programming language uses the
more readable it is, because the code will be more compact and easier to
get an overview of. Additionally fewer lines of code indicate that the
programming language uses less boilerplate making it easier to read. \\
Additionally to the code being more readable it is also easier to maintain due
to there being fewer lines making it easier to identify where modifications need
to be made.

To compare the lines of code we created a comparison project in Java and used
the tool cloc\cite{cloc} to compare the projects. Figure \ref{fig:locKoltin} and
\ref{fig:locJava} show the result of this comparison and shows that for the same
project Kotlin uses 29\% fewer lines of code than Java. The biggest difference
in the lines of code stems from data classes in Kotlin not requiring
constructors and getters/setters. Making the data classes a lot shorter and
thereby easier to read and understand. \\
Even though Java also offers a way of creating class without the need for
getters and setters in the form of \lstinline{records} they are not entirely
interchangeable with classes and for example can not be used to create
\lstinline{JPA} entities, because they are final \cite{record}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./figs/locKotlin.png}
	\caption{Lines of code Kotlin prototype.}
	\label{fig:locKoltin}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./figs/locJava.png}
	\caption{Lines of code Java comparison project.}
	\label{fig:locJava}
\end{figure}

Even though Kotlin uses fewer lines of code and is generally more readable
because of that, there are exceptions. The following two code examples show the
same logic for calling a function and returning something depending on whether
the function returns an object or not in Kotlin and Java. Even though Kotlin
uses just two lines of code in comparison to Javas six it is arguably less
readable.

\begin{lstlisting}[language=Java, caption=Function call and verification in Kotlin]
return feedAppManager.addPoll(username, pollRequest)?.let { ResponseEntity.ok(it) }
        ?: ResponseEntity.status(HttpStatus.NOT_FOUND).build()
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Function call and verification in Java]
Poll poll = feedAppManager.addPoll(username, pollRequest);
if (poll != null) {
	return ResponseEntity.ok(poll);
} else {
	return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
}
\end{lstlisting}
