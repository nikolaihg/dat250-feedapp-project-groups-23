\section{Technology Assessment}
\label{sec:technology}


Introduce in (sufficient) depth the key concepts and architecture of the chosen software technology. As part if this, you may consider using a running example to introduce the technology.

This part and other parts of the report probably needs to refer to
figures. Figure~\ref{fig:framework} from \cite{brown:96} just
illustrates how figure can be included in the report.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{figs/framework.png}
	\caption{Software technology evaluation framework.}
	\label{fig:framework}
\end{figure}

\subsection{Descriptive Modeling}

write where the technology comes from, its history, its context and what problem it solves.
Consider drawing a graph like in \cite{brown:96}.

\subsection{Experiment Design}
\subsubsection{Introduction}

The selection of the programming language is one of the first and most significant decisions in development. It reflects productivity, quality, and maintainability of the software being developed. In today's back-end era, the default pick of enterprise systems remains Java. This is because the language is mature, stable, and highly supported. Kotlin, a fairly new statically typed programming language, is threatening Java. It is completely compatible with Java and enjoys the official backing of the Spring Framework. Kotlin is guaranteed to be safer and shorter to code without sacrificing compatibility with current JVM technologies. This paper aims to utilize Kotlin rather than Java in building a web application of voting polls on the Brown and Wallnau's Technology Delta Framework (1999). The said framework provides a systematic way of establishing the value of a technology over another and the consequent use of the technology genealogies, delta feature sets, and real application case scenarios. The strategy uses the trade-off between value and risk and the next value of technology.


The choice of the application, REST-based poll-voting feature with user support for creating polls, voting, and viewing results in real-time is a realistic and challenging backend development project. It requires the capability to manage system concurrency, ensure transactional consistency of the system, provide system scalability and fast feature iteration. It is therefore well-suited to test out some of Kotlin's new language features such as null-safety, coroutines, data classes, and type inference.


This research compares Kotlin and Java, not as distinct programming languages but as different technology stacks to solve the same application development issue in a given context.

It aims to establish whether Kotlin brings a real improvement in a programmer's productivity and system stability as long as there are no compromises in execution performance and interoperability. Following Brown and Wallnau, the experiment aims to provide a justification for Kotlin adoption in the proposed software situation, evidenced by facts through descriptive modeling, experiment design, and evaluation.

\subsection{Descriptive Modelling}
The first phase of the Technology Delta Framework involves constructing a descriptive model of the technologies being compared. This stage identifies their genealogy, situates them within the problem habitat, and defines the feature deltas that distinguish one technology from the other. The goal is to establish a clear conceptual understanding of what Kotlin introduces beyond Java, before any empirical testing is undertaken.

\subsubsection{Technology Genealogy}
Java and Kotlin have a shared family of technologies, the Java Virtual Machine (JVM) platform.
Java is an object-orientated statically typed programming language that was developed by Sun Microsystems in 1995. Java became popular due to its portability, mature tooling, and rich libraries. The design of Java was based on backward compatibility and explicitness. Java is a secure but verbose choice for most large systems, and increasingly Java has added more functional programming capabilities such as lambdas, streams, records, sealed classes, and virtual threads. That is, Java meeting the needs of expressiveness and concurrency.
Kotlin was created by JetBrains in 2011. Kotlin was marketed as a practical evolution of Java.
It was designed to solve Java's verbosity, its null-safety gap, and poor support for modern development paradigms with complete Java library and framework interoperability. It is also formally supported by notable JVM frameworks like Spring and Android and compiles to the same JVM bytecode. The design of Kotlin is conciseness-focused and safety, with interoperability, whereby one may use a more expressive syntax and a stable type system. Kotlin does not replace Java yet, however, it can be said to be an evolutionary offspring on the JVM family tree. It takes the core features of Java and extends them with other language elements from functional languages and statically typed languages like Scala, Swift, and C\#.

\subsubsection{Problem Habitat}

\subsubsection{Feature Deltas}

The \textit{feature deltas} represent the specific technological innovations or differences introduced by Kotlin relative to Java.
These are the ``points of departure'' that may influence quality, cost, or performance outcomes within this application's habitat.

\begin{table}[H]
\centering
\caption{Feature Deltas between Java and Kotlin}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}p{0.17\linewidth} p{0.17\linewidth} p{0.17\linewidth} p{0.17\linewidth}@{}}
\toprule
\textbf{Feature Delta} & \textbf{Java (Baseline)} & \textbf{Kotlin (New Capability)} & \textbf{Potential Impact} \\
\midrule
\textbf{Null-safety} &
Nullable references unchecked at compile time &
Non-nullable types enforced by compiler &
Reduces null pointer exceptions and improves reliability. \\

\textbf{Data classes} &
Verbose POJO definitions or JDK records (since Java 16) &
One-line \texttt{data class} with auto-generated methods &
Reduces boilerplate; increases development speed and readability. \\

\textbf{Type inference and concise syntax} &
Explicit type declarations &
Implicit typing with smart inference &
Simplifies code and reduces cognitive load on developers. \\

\textbf{Coroutines and structured concurrency} &
Threads, Executors, \texttt{CompletableFuture}, or Virtual Threads &
Lightweight coroutines with \texttt{suspend} functions &
Improves scalability and simplifies asynchronous programming. \\

\textbf{Extension functions} &
Utility methods via static helper classes &
Ability to attach behaviour directly to existing classes &
Enhances readability and enables domain-specific DSLs (e.g., Spring configuration). \\

\textbf{Sealed and inline classes} &
Limited polymorphic control (until Java 17) &
Exhaustive \texttt{when} expressions and sealed hierarchies &
Safer domain modelling and compile-time exhaustiveness checks. \\

\textbf{Interop with Java} &
Native language; direct compatibility &
Full interop using \texttt{@Jvm*} annotations and mixed modules &
Enables gradual adoption and reuse of existing Java codebases. \\

\textbf{Tooling and ecosystem support} &
Broad IDE and build support (Eclipse, IntelliJ, Gradle) &
First-class support in IntelliJ IDEA, Gradle, and Spring Boot &
Comparable or improved developer experience and productivity. \\
\bottomrule
\end{tabular}
\end{table}

From a descriptive perspective, Kotlin’s deltas can be grouped into three broad categories:
\begin{enumerate}
    \item \textbf{Safety} – achieved through null-safety and sealed type hierarchies.
    \item \textbf{Expressiveness} – enabled by concise syntax, data classes, and extension functions.
    \item \textbf{Concurrency and performance} – improved through lightweight coroutines and structured concurrency.
\end{enumerate}

These deltas form the foundation for the next phase of the framework—designing controlled experiments and refutable hypotheses to measure Kotlin’s actual added value over Java within this software habitat.

\subsection{Experiment Evaluation}

Write about the results of your experiments, either via personal experience reports, quantitative benchmarks, a demostrator case study or a combination of multiple approaches.


For some reports you may have to include a table with experimental
results are other kinds of tables that for instance compares
technologies. Table~\ref{tab:results} gives an example of how to create a table.

\begin{table}[bth]
	\centering
	\begin{tabular}{llrrrrrr}
		Config & Property & States & Edges & Peak & E-Time & C-Time & T-Time
		\\ \hline \hline
		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  485.7\% \\
		22-2 & A   &    7,944  &   22,419  &  6.6  \%  &  7 ms & 42.9\% &  471.4\% \\
		30-2 & B   &   14,672  &   41,611  &  4.9  \%  & 14 ms & 42.9\% &  464.3\% \\
		30-2 & C   &   14,672  &   41,611  &  4.9  \%  & 15 ms & 40.0\% &  420.0\% \\ \hline
		10-3 & D   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 31.4\% &  285.7\% \\
		10-3 & E   &   24,052  &   98,671  & 19.8  \%  & 35 ms & 34.3\% &  308.6\% \\
		\hline \hline
	\end{tabular}
	\caption{Selected experimental results on the communication protocol example.}
	\label{tab:results}
\end{table}

\subsubsection{Readability and Maintainability}

To verify the hypotheses that Kotlin code is more readable than Java code we
took the lines of code into account. \\
Our assumptions in regard to this factor is that code is generally more
readable if it has less lines of code compared to another language.
The reasoning for this is: The fewer lines of code a programming language uses the
more readable it is, because the code will be more compact and easier to
get an overview of. Additionally fewer lines of code indicate that the
programming language uses less boilerplate making it easier to read. \\
Additionally to the code being more readable it is also easier to maintain due
to there being fewer lines making it easier to identify where modifications need
to be made.

To compare the lines of code we created a comparison project in Java and used
the tool cloc\cite{cloc} to compare the projects. Figure \ref{fig:locKoltin} and
\ref{fig:locJava} show the result of this comparison and shows that for the same
project Kotlin uses 29\% fewer lines of code than Java. The biggest difference
in the lines of code stems from data classes in Kotlin not requiring
constructors and getters/setters. Making the data classes a lot shorter and
thereby easier to read and understand. \\
Even though Java also offers a way of creating class without the need for
getters and setters in the form of \lstinline{records} they are not entirely
interchangeable with classes and for example can not be used to create
\lstinline{JPA} entities, because they are final \cite{record}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./figs/locKotlin.png}
	\caption{Lines of code Kotlin prototype.}
	\label{fig:locKoltin}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./figs/locJava.png}
	\caption{Lines of code Java comparison project.}
	\label{fig:locJava}
\end{figure}

Even though Kotlin uses fewer lines of code and is generally more readable
because of that, there are exceptions. The following two code examples show the
same logic for calling a function and returning something depending on whether
the function returns an object or not in Kotlin and Java. Even though Kotlin
uses just two lines of code in comparison to Javas six it is arguably less
readable.

\begin{lstlisting}[language=Java, caption=Function call and verification in Kotlin]
return feedAppManager.addPoll(username, pollRequest)?.let { ResponseEntity.ok(it) }
        ?: ResponseEntity.status(HttpStatus.NOT_FOUND).build()
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Function call and verification in Java]
Poll poll = feedAppManager.addPoll(username, pollRequest);
if (poll != null) {
	return ResponseEntity.ok(poll);
} else {
	return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
}
\end{lstlisting}
